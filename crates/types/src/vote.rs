//! Vote and vote accumulator types
//!
//! This module contains types used to represent the various types of votes that `HotShot` nodes
//! can send, and vote accumulator that converts votes into certificates.

use crate::{
    certificate::AssembledSignature,
    traits::{
        election::{VoteData, VoteToken},
        node_implementation::NodeType,
        signature_key::{EncodedPublicKey, EncodedSignature, SignatureKey},
    },
};
use bincode::Options;
use bitvec::prelude::*;
use commit::{Commitment, CommitmentBounds, Committable};
use either::Either;
use ethereum_types::U256;
use hotshot_utils::bincode::bincode_opts;
use serde::{Deserialize, Serialize};
use std::{
    collections::{BTreeMap, HashMap},
    fmt::Debug,
    hash::Hash,
    num::NonZeroU64,
};
use tracing::error;

/// The vote sent by consensus messages.
pub trait VoteType<TYPES: NodeType, COMMITMENT: CommitmentBounds>:
    Debug + Clone + 'static + Serialize + for<'a> Deserialize<'a> + Send + Sync + PartialEq
{
    /// Get the view this vote was cast for
    fn get_view(&self) -> TYPES::Time;
    /// Get the signature key associated with this vote
    fn get_key(&self) -> TYPES::SignatureKey;
    /// Get the signature associated with this vote
    fn get_signature(&self) -> EncodedSignature;
    /// Get the data this vote was signed over
    fn get_data(&self) -> VoteData<COMMITMENT>;
    /// Get the vote token of this vote
    fn get_vote_token(&self) -> TYPES::VoteTokenType;
}

/// The internals of a view sync vote
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, Hash)]
#[serde(bound(deserialize = ""))]
pub struct ViewSyncVoteInternal<TYPES: NodeType> {
    /// The public key associated with the relay.
    pub relay_pub_key: EncodedPublicKey,
    /// The relay this vote is intended for
    pub relay: u64,
    /// The view number we are trying to sync on
    pub round: TYPES::Time,
    /// This node's signature over the VoteData
    pub signature: (EncodedPublicKey, EncodedSignature),
    /// The vote token generated by this replica
    pub vote_token: TYPES::VoteTokenType,
    /// The vote data this vote is signed over
    pub vote_data: VoteData<Commitment<ViewSyncData<TYPES>>>,
}

/// The data View Sync votes are signed over
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Hash, Eq)]
#[serde(bound(deserialize = ""))]
pub struct ViewSyncData<TYPES: NodeType> {
    /// The relay this vote is intended for
    pub relay: EncodedPublicKey,
    /// The view number we are trying to sync on
    pub round: TYPES::Time,
}

impl<TYPES: NodeType> Committable for ViewSyncData<TYPES> {
    fn commit(&self) -> Commitment<Self> {
        let builder = commit::RawCommitmentBuilder::new("Quorum Certificate Commitment");

        builder
            .var_size_field("Relay public key", &self.relay.0)
            .u64(*self.round)
            .finalize()
    }
}

/// Votes to synchronize the network on a single view
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, Hash)]
#[serde(bound(deserialize = ""))]
pub enum ViewSyncVote<TYPES: NodeType> {
    /// PreCommit vote
    PreCommit(ViewSyncVoteInternal<TYPES>),
    /// Commit vote
    Commit(ViewSyncVoteInternal<TYPES>),
    /// Finalize vote
    Finalize(ViewSyncVoteInternal<TYPES>),
}

impl<TYPES: NodeType> ViewSyncVote<TYPES> {
    /// Get the encoded signature.
    pub fn signature(&self) -> EncodedSignature {
        match &self {
            ViewSyncVote::PreCommit(vote_internal)
            | ViewSyncVote::Commit(vote_internal)
            | ViewSyncVote::Finalize(vote_internal) => vote_internal.signature.1.clone(),
        }
    }
    /// Get the signature key.
    /// # Panics
    /// If the deserialization fails.
    pub fn signature_key(&self) -> TYPES::SignatureKey {
        let encoded = match &self {
            ViewSyncVote::PreCommit(vote_internal)
            | ViewSyncVote::Commit(vote_internal)
            | ViewSyncVote::Finalize(vote_internal) => vote_internal.signature.0.clone(),
        };
        <TYPES::SignatureKey as SignatureKey>::from_bytes(&encoded).unwrap()
    }
    /// Get the relay.
    pub fn relay(&self) -> u64 {
        match &self {
            ViewSyncVote::PreCommit(vote_internal)
            | ViewSyncVote::Commit(vote_internal)
            | ViewSyncVote::Finalize(vote_internal) => vote_internal.relay,
        }
    }
    /// Get the round number.
    pub fn round(&self) -> TYPES::Time {
        match &self {
            ViewSyncVote::PreCommit(vote_internal)
            | ViewSyncVote::Commit(vote_internal)
            | ViewSyncVote::Finalize(vote_internal) => vote_internal.round,
        }
    }
}

impl<TYPES: NodeType> VoteType<TYPES, Commitment<ViewSyncData<TYPES>>> for ViewSyncVote<TYPES> {
    fn get_view(&self) -> TYPES::Time {
        match self {
            ViewSyncVote::PreCommit(v) | ViewSyncVote::Commit(v) | ViewSyncVote::Finalize(v) => {
                v.round
            }
        }
    }
    fn get_key(&self) -> <TYPES as NodeType>::SignatureKey {
        self.signature_key()
    }

    fn get_signature(&self) -> EncodedSignature {
        self.signature()
    }
    fn get_data(&self) -> VoteData<Commitment<ViewSyncData<TYPES>>> {
        match self {
            ViewSyncVote::PreCommit(vote_internal)
            | ViewSyncVote::Commit(vote_internal)
            | ViewSyncVote::Finalize(vote_internal) => vote_internal.vote_data.clone(),
        }
    }

    fn get_vote_token(&self) -> <TYPES as NodeType>::VoteTokenType {
        match self {
            ViewSyncVote::PreCommit(vote_internal)
            | ViewSyncVote::Commit(vote_internal)
            | ViewSyncVote::Finalize(vote_internal) => vote_internal.vote_token.clone(),
        }
    }
}

/// Accumulates view sync votes
pub struct ViewSyncVoteAccumulator<TYPES: NodeType> {
    /// Map of all pre_commit signatures accumlated so far
    pub pre_commit_vote_outcomes: VoteMap<Commitment<ViewSyncData<TYPES>>, TYPES::VoteTokenType>,
    /// Map of all ommit signatures accumlated so far
    pub commit_vote_outcomes: VoteMap<Commitment<ViewSyncData<TYPES>>, TYPES::VoteTokenType>,
    /// Map of all finalize signatures accumlated so far
    pub finalize_vote_outcomes: VoteMap<Commitment<ViewSyncData<TYPES>>, TYPES::VoteTokenType>,

    /// A quorum's worth of stake, generally 2f + 1
    pub success_threshold: NonZeroU64,
    /// A quorum's failure threshold, generally f + 1
    pub failure_threshold: NonZeroU64,
    /// A list of valid signatures for certificate aggregation
    pub sig_lists: Vec<<TYPES::SignatureKey as SignatureKey>::PureAssembledSignatureType>,
    /// A bitvec to indicate which node is active and send out a valid signature for certificate aggregation, this automatically do uniqueness check
    pub signers: BitVec,
}

impl<TYPES: NodeType> ViewSyncVoteAccumulator<TYPES> {
    /// append a vote
    /// # Panics
    /// if serialize fails
    #[allow(clippy::too_many_lines)]
    pub fn append(
        mut self,
        vote: &ViewSyncVote<TYPES>,
        vote_node_id: usize,
        stake_table_entries: Vec<<TYPES::SignatureKey as SignatureKey>::StakeTableEntry>,
    ) -> Either<Self, AssembledSignature<TYPES>> {
        let (VoteData::ViewSyncPreCommit(vote_commitment)
        | VoteData::ViewSyncCommit(vote_commitment)
        | VoteData::ViewSyncFinalize(vote_commitment)) = vote.get_data()
        else {
            return Either::Left(self);
        };

        // error!("Vote is {:?}", vote.clone());

        let encoded_key = vote.get_key().to_bytes();

        // Deserialize the signature so that it can be assembeld into a QC
        // TODO ED Update this once we've gotten rid of EncodedSignature
        let original_signature: <TYPES::SignatureKey as SignatureKey>::PureAssembledSignatureType =
            bincode_opts()
                .deserialize(&vote.get_signature().0)
                .expect("Deserialization on the signature shouldn't be able to fail.");

        let (pre_commit_stake_casted, pre_commit_vote_map) = self
            .pre_commit_vote_outcomes
            .entry(vote_commitment)
            .or_insert_with(|| (0, BTreeMap::new()));

        // Check for duplicate vote
        if pre_commit_vote_map.contains_key(&encoded_key) {
            return Either::Left(self);
        }

        let (commit_stake_casted, commit_vote_map) = self
            .commit_vote_outcomes
            .entry(vote_commitment)
            .or_insert_with(|| (0, BTreeMap::new()));

        if commit_vote_map.contains_key(&encoded_key) {
            return Either::Left(self);
        }

        let (finalize_stake_casted, finalize_vote_map) = self
            .finalize_vote_outcomes
            .entry(vote_commitment)
            .or_insert_with(|| (0, BTreeMap::new()));

        if finalize_vote_map.contains_key(&encoded_key) {
            return Either::Left(self);
        }

        // update the active_keys and sig_lists
        // TODO ED Possible bug where a node sends precommit vote and then commit vote after
        // precommit cert is formed, their commit vote won't be counted because of this check
        // Probably need separate signers vecs.
        if self.signers.get(vote_node_id).as_deref() == Some(&true) {
            error!("node id already in signers");
            return Either::Left(self);
        }
        self.signers.set(vote_node_id, true);
        self.sig_lists.push(original_signature);

        match vote.get_data() {
            VoteData::ViewSyncPreCommit(_) => {
                *pre_commit_stake_casted += u64::from(vote.get_vote_token().vote_count());
                pre_commit_vote_map.insert(
                    encoded_key,
                    (vote.get_signature(), vote.get_data(), vote.get_vote_token()),
                );
            }
            VoteData::ViewSyncCommit(_) => {
                *commit_stake_casted += u64::from(vote.get_vote_token().vote_count());
                commit_vote_map.insert(
                    encoded_key,
                    (vote.get_signature(), vote.get_data(), vote.get_vote_token()),
                );
            }
            VoteData::ViewSyncFinalize(_) => {
                *finalize_stake_casted += u64::from(vote.get_vote_token().vote_count());
                finalize_vote_map.insert(
                    encoded_key,
                    (vote.get_signature(), vote.get_data(), vote.get_vote_token()),
                );
            }
            _ => unimplemented!(),
        }

        if *pre_commit_stake_casted >= u64::from(self.failure_threshold) {
            let real_qc_pp = <TYPES::SignatureKey as SignatureKey>::get_public_parameter(
                stake_table_entries,
                U256::from(self.failure_threshold.get()),
            );

            let real_qc_sig = <TYPES::SignatureKey as SignatureKey>::assemble(
                &real_qc_pp,
                self.signers.as_bitslice(),
                &self.sig_lists[..],
            );

            self.pre_commit_vote_outcomes
                .remove(&vote_commitment)
                .unwrap();
            return Either::Right(AssembledSignature::ViewSyncPreCommit(real_qc_sig));
        }

        if *commit_stake_casted >= u64::from(self.success_threshold) {
            let real_qc_pp = <TYPES::SignatureKey as SignatureKey>::get_public_parameter(
                stake_table_entries,
                U256::from(self.success_threshold.get()),
            );

            let real_qc_sig = <TYPES::SignatureKey as SignatureKey>::assemble(
                &real_qc_pp,
                self.signers.as_bitslice(),
                &self.sig_lists[..],
            );
            self.commit_vote_outcomes.remove(&vote_commitment).unwrap();
            return Either::Right(AssembledSignature::ViewSyncCommit(real_qc_sig));
        }

        if *finalize_stake_casted >= u64::from(self.success_threshold) {
            let real_qc_pp = <TYPES::SignatureKey as SignatureKey>::get_public_parameter(
                stake_table_entries,
                U256::from(self.success_threshold.get()),
            );

            let real_qc_sig = <TYPES::SignatureKey as SignatureKey>::assemble(
                &real_qc_pp,
                self.signers.as_bitslice(),
                &self.sig_lists[..],
            );
            self.finalize_vote_outcomes
                .remove(&vote_commitment)
                .unwrap();
            return Either::Right(AssembledSignature::ViewSyncFinalize(real_qc_sig));
        }

        Either::Left(self)
    }
}

/// Mapping of commitments to vote tokens by key.
type VoteMap<COMMITMENT, TOKEN> = HashMap<
    COMMITMENT,
    (
        u64,
        BTreeMap<EncodedPublicKey, (EncodedSignature, VoteData<COMMITMENT>, TOKEN)>,
    ),
>;
